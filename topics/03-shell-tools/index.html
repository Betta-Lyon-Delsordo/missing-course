<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>/topics/03-shell-tools [missing course]</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
  pre code {
      background-color: lightgoldenrodyellow;
      border-radius: 1.0rem;
      display: block;
      font-size: 0.8rem;
      padding: 1.0rem;
  }
  </style>
</head>
<body>
<h1 id="shell-tools">Shell Tools</h1>
<ul>
<li><a href="https://missing.csail.mit.edu/2020/shell-tools/">MIT Page</a> (second half)</li>
</ul>
<p>There exists a plethora of useful command line tools. We’re going to take a look at a few that are likely to be helpful as you work your way through school and begin a career as a computer scientist or software developer.</p>
<h2 id="history">History</h2>
<p>Remember that complicated command you used to do that complicated thing the other day? Yeah, no one does. That’s why we have <code>Ctrl-R</code>. This allows you to easily find a command you’ve run in the past to (optionally) edit and run again.</p>
<ul>
<li><a href="https://youtu.be/Hj6Us07MTRM">Example Video</a></li>
</ul>
<p>There is also a command called <code>history</code> that will simply print a list of your past commands. This can be useful if you want to copy-paste commands into a document or otherwise make use of your history in ways other than running a single command.</p>
<h2 id="navigate-and-browse">Navigate and Browse</h2>
<ul>
<li><a href="https://linux.die.net/man/1/tree">Tree</a></li>
<li><a href="https://github.com/wting/autojump">Autojump</a></li>
<li><a href="https://github.com/clvv/fasd">Fasd</a></li>
</ul>
<p>We already looked at <code>cd</code>, <code>ls</code>, and <code>pwd</code> for navigating the filesystem, but there are a few other commands that can make life easier.</p>
<h3 id="tree">Tree</h3>
<p>This command, which will need to be installed on most systems (you can use <code>brew install tree</code> on a Mac), prints a directory hierarchy as a pleasant ASCII art diagram. For example, running it on this repository directory:</p>
<pre><code>missing-course on  master [!]
➜ tree .
.
├── AUTHORS
├── LICENSE
├── Makefile
├── README.md
├── index.html
├── media
│   ├── header.html
│   ├── header.jpg
│   └── videos
│       └── ctrl-r-demo.mov
└── topics
    ├── 01-shell-overview
    │   ├── README.md
    │   └── index.html
    ├── 02-shell-scripting
    │   ├── README.md
    │   └── index.html
    ├── 03-shell-tools
    │   ├── README.md
    │   └── index.html
    ├── README.md
    └── index.html

6 directories, 16 files</code></pre>
<h3 id="stack-commands">Stack Commands</h3>
<p>The <code>pushd</code> and <code>popd</code> commands allow you to create a stack of directories so that you can retrace your steps back to your starting position.</p>
<pre><code># Assume we start in the home directory
cd

# Time to work on some code
cd Code/awesome-project

# Go update the paper we&#39;re writing about this project
pushd ~/Documents/awesome-project-paper

# Jump back to the code without typing the directory again
popd</code></pre>
<h3 id="fasd-and-autojump">Fasd and Autojump</h3>
<p><a href="https://github.com/clvv/fasd">Fasd</a> and <a href="https://github.com/wting/autojump">Autojump</a> allow the user to navigate to directories they have previously visited using “fuzzy” matching and the concept of “frecency” (frequency combined with recent). For example, starting in my home directory I can jump all the way into the directory belonging to a particular project (that I work on semi-regularly) simply by providing the name of the project’s directory (or even part of it). Note that <code>j</code> here is an alias that runs autojump with the correct arguments.</p>
<pre><code>~ $ # We start in the home directory
~ $ j polyA
~/Code/TravisWheelerLab/polyA $ # Now we&#39;re here!</code></pre>
<h2 id="grep-and-friends">Grep and Friends</h2>
<ul>
<li><a href="https://github.com/ggreer/the_silver_searcher">The Silver Searcher</a></li>
<li><a href="https://github.com/BurntSushi/ripgrep">Ripgrep</a></li>
</ul>
<p>Grep can find occurrences of a specific string or regular expression within text files.</p>
<pre><code># Find &quot;Missing&quot; in the file README.md
grep Missing README.md`

# Find &quot;command&quot; in all files under the current directory, recursively
grep -r Missing .

# Only print filenames, not the line that matched
grep -lr command .

# Print some context around each match (2 lines)
grep -r -C2 command .

# Print filenames that did not match
grep -rL Missing .</code></pre>
<h3 id="history-redux">History Redux</h3>
<p>Remember the <code>history</code> command? We can use a Unix pipe along with grep to find all similar commands we’ve run in the past. For example, sometimes it is useful to recall which packages have been installed through Homebrew. The following command can find all invocations of <code>brew install</code>:</p>
<pre><code>history | grep &quot;brew install&quot;</code></pre>
<h3 id="silver-searcher-and-ripgrep">Silver Searcher and Ripgrep</h3>
<p>These tools act a lot like Grep, but provide better performance and other features that make them more pleasant to use. For example, they can respect your version control system’s “ignore” file to avoid generating extra, useless results.</p>
<pre><code>ag &quot;search term&quot;</code></pre>
<h2 id="find">Find</h2>
<p>We’ve talked a lot about how to navigate the file system and work with files, but what about finding files based on their name or other characteristics? For this, we have the <code>find</code> command.</p>
<pre><code>find . -name myfile

# We can also filter by type, which is often useful
# for limiting our results to only regular files
# (excluding directories and symlinks, for example).
find . -type f -name myfile

# It is also possible to negate filters. The command
# below finds all files that do not have a .py
# extension.
find . -type f ! -name &#39;*.py&#39;</code></pre>
<p>It is also possible to have find run a command on each file it finds. This can be helpful if you want to run a command against several different files to produce an output for each.</p>
<pre><code># Run the mypy type checker against all Python files
# found in or below the current directory.
find . -type f -name &#39;*.py&#39; -exec mypy {} \;</code></pre>
<h2 id="parallelize-commands">Parallelize Commands</h2>
<ul>
<li><a href="https://www.gnu.org/software/parallel/">GNU Parallel</a></li>
<li><a href="https://www.usenix.org/system/files/login/articles/105438-Tange.pdf">GNU Parallel Tutorial</a></li>
</ul>
<p>You might notice that the <code>find</code> command above takes a few seconds if there are many Python files. That’s partly because mypy is run against each file in serial. We could speed things up by running mypy in parallel and we can use the <code>parallel</code> command to do it. Note: this is another one of those commands you’ll probably have to install, it doesn’t ship with most systems.</p>
<p>Let’s play around a bit…</p>
<pre><code># Create a bunch of empty files
touch file-{001..100}.txt

# Put some data in each file, in this case
# just a bunch of words
find . -name &#39;*.txt&#39; -exec sh -c &quot;head -100000 /usr/share/dict/words &gt; {}&quot; \;

# Use find to compress all of the files
# and time how long it takes, then decompress
time find . -name &#39;*.txt&#39; -exec gzip {} \;
time find . -name &#39;*.gz&#39; -exec gunzip {} \;

# Use parallel to compress all of the files
# and time how long it takes, then decompress
time parallel gzip ::: *.txt
time parallel gunzip ::: *.gz</code></pre>
<p>You’ll notice that there wasn’t much difference, that’s because our task is mostly I/O bound anyway, but take a look at the CPU percentage, you can tell the tasks are being parallelized because the CPU usage is much higher in the second version.</p>
<p>Now let’s create a more complicated example that should actually result in better performance when we parallelize the work. This is still going to be rather contrived, but it shouldn’t be hard to imagine how it could be translated to real work.</p>
<p>First, we’ll write a program that does something CPU bound. Then we’ll want a quick script to create bogus data for that program to operate on.</p>
<ul>
<li><a href="is_prime.py">is_prime.py</a> - <code>./is_prime.py &lt;file&gt;</code></li>
<li><a href="random_numbers.py">random_numbers.py</a> - <code>./random_numbers.py &lt;N&gt; &lt;size&gt;</code></li>
</ul>
<p>Now let’s try the same thing we did above, compare the performance of <code>find</code> and <code>parallel</code>.</p>
<pre><code>mkdir scratch
cd scratch
touch numbers-{00..20}.txt
find . -name &#39;*.txt&#39; -exec sh -c &quot;../random_numbers.py 10 24 &gt; {}&quot; \;

time find . -name &#39;*.txt&#39; -exec ../is_prime.py {} \;
time parallel ../is_prime.py ::: *.txt</code></pre>
<p>You should see that <code>parallel</code> is quite a bit faster now that our work is CPU bound. On my machine, <code>find</code> takes about 35 seconds and <code>parallel</code> takes about 8 seconds.</p>
</body>
</html>
